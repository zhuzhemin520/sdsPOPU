(this["webpackJsonppopulation-arcgis"]=this["webpackJsonppopulation-arcgis"]||[]).push([[89],{1194:function(e,t,n){"use strict";function r(e,t){var n;return e.isGeographic||e.isWebMercator&&(null==(n=null==t?void 0:t.geographic)||n)}n.d(t,"a",(function(){return r}))},1222:function(e,t,n){"use strict";n.d(t,"a",(function(){return O})),n.d(t,"b",(function(){return j})),n.d(t,"c",(function(){return d})),n.d(t,"d",(function(){return m})),n.d(t,"e",(function(){return y}));var r=n(2),o=n(68),a=n(118),i=n(30),s=n(35),c=n(81),l=n(40),u=n(66),b=n(1245),f=n(38),p=n(279),h=n(1194),g=n(607);function O(e,t,n){return Object(h.a)(t.spatialReference,n)?function(e,t,n){const r=t.spatialReference,o=R(t,n,L),a=new Float64Array(e.position.length),i=function(e,t,n,r){Object(p.e)(f.v.fromTypedArray(r),f.v.fromTypedArray(e),t);const o=new Float64Array(e.length);return Object(g.a)(r,o,n)}(e.position,o,r,a),s=Object(c.a)(k,o);return{position:i,normal:x(i,a,e.normal,s,r),tangent:v(i,a,e.tangent,s,r)}}(e,t,n):function(e,t,n){const r=new Float64Array(e.position.length),o=e.position,a=t.x,i=t.y,s=t.z||0,{horizontal:c,vertical:l}=E(n?n.unit:null,t.spatialReference);for(let u=0;u<o.length;u+=3)r[u+0]=o[u+0]*c+a,r[u+1]=o[u+1]*c+i,r[u+2]=o[u+2]*l+s;return{position:r,normal:e.normal,tangent:e.tangent}}(e,t,n)}function j(e,t,n){const{position:o,normal:a,tangent:i}=e;if(Object(r.k)(t))return{position:o,normal:a,tangent:i};const s=t.localMatrix;return O({position:Object(g.h)(o,new Float64Array(o.length),s),normal:Object(r.l)(a)?Object(g.g)(a,new Float32Array(a.length),s):null,tangent:Object(r.l)(i)?Object(g.i)(i,new Float32Array(i.length),s):null},t.getOriginPoint(n),{geographic:t.geographic})}function d(e,t,n){if(null!=n&&n.useTransform){var r;const{position:o,normal:a,tangent:i}=e;return{vertexAttributes:{position:o,normal:a,tangent:i},transform:new b.a({origin:[t.x,t.y,null!=(r=t.z)?r:0],geographic:Object(h.a)(t.spatialReference,n)})}}return{vertexAttributes:O(e,t,n),transform:null}}function m(e,t,n){return Object(h.a)(t.spatialReference,n)?A(e,t,n):w(e,t,n)}function y(e,t,n,o){if(Object(r.k)(t))return m(e,n,o);const a=j(e,t,n.spatialReference);return n.equals(t.getOriginPoint(n.spatialReference))?w(a,n,o):Object(h.a)(n.spatialReference,o)?A(a,n,o):w(a,n,o)}function x(e,t,n,o,a){if(Object(r.k)(n))return null;const i=new Float32Array(n.length);return Object(p.a)(f.u.fromTypedArray(i),f.u.fromTypedArray(n),o),Object(g.b)(i,e,t,a,i),i}function v(e,t,n,o,a){if(Object(r.k)(n))return null;const i=new Float32Array(n.length);Object(p.a)(f.u.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT),f.u.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),o);for(let r=3;r<i.length;r+=4)i[r]=n[r];return Object(g.d)(i,e,t,a,i),i}function w(e,t,n){const r=new Float64Array(e.position.length),o=e.position,a=t.x,i=t.y,s=t.z||0,{horizontal:c,vertical:l}=E(n?n.unit:null,t.spatialReference);for(let u=0;u<o.length;u+=3)r[u+0]=(o[u+0]-a)/c,r[u+1]=(o[u+1]-i)/c,r[u+2]=(o[u+2]-s)/l;return{position:r,normal:e.normal,tangent:e.tangent}}function A(e,t,n){const r=t.spatialReference;R(t,n,L);const o=Object(i.d)(P,L),a=new Float64Array(e.position.length),s=function(e,t,n,r){const o=Object(g.f)(e,t,r),a=f.v.fromTypedArray(o),i=new Float64Array(o.length),s=f.v.fromTypedArray(i);return Object(p.e)(s,a,n),i}(e.position,r,o,a),l=Object(c.a)(k,o);return{position:s,normal:F(e.normal,e.position,a,r,l),tangent:M(e.tangent,e.position,a,r,l)}}function R(e,t,n){Object(l.d)(e.spatialReference,[e.x,e.y,e.z||0],n,Object(u.g)(e.spatialReference));const{horizontal:r,vertical:o}=E(t?t.unit:null,e.spatialReference);return Object(i.n)(n,n,[r,r,o]),n}function F(e,t,n,o,a){if(Object(r.k)(e))return null;const i=Object(g.c)(e,t,n,o,new Float32Array(e.length)),s=f.u.fromTypedArray(i);return Object(p.a)(s,s,a),i}function M(e,t,n,o,a){if(Object(r.k)(e))return null;const i=Object(g.e)(e,t,n,o,new Float32Array(e.length)),s=f.u.fromTypedArray(i,4*Float32Array.BYTES_PER_ELEMENT);return Object(p.a)(s,s,a),i}function E(e,t){if(Object(r.k)(e))return T;const n=t.isGeographic?1:Object(o.f)(t),a=t.isGeographic?1:Object(o.g)(t),i=Object(o.d)(1,e,"meters");return{horizontal:i*n,vertical:i*a}}const L=Object(s.d)(),P=Object(s.d)(),k=Object(a.b)(),T={horizontal:1,vertical:1}},1245:function(e,t,n){"use strict";n.d(t,"a",(function(){return A}));var r,o=n(0),a=n(27),i=n(2),s=n(1),c=(n(17),n(12),n(10)),l=n(30),u=n(35),b=n(201),f=n(264),p=n(5),h=n(9),g=n(62),O=n(40),j=n(66),d=n(601),m=n(38),y=n(279),x=n(515);let v=r=class extends a.a{constructor(e){super(e),this.origin=Object(h.f)(),this.translation=Object(h.f)(),this.rotation=Object(d.e)(),this.scale=Object(h.h)(1,1,1),this.geographic=!0}get localMatrix(){const e=Object(u.d)();return Object(b.i)(w,Object(d.c)(this.rotation),Object(d.b)(this.rotation)),Object(l.j)(e,w,this.translation,this.scale),e}get localMatrixInverse(){return Object(l.d)(Object(u.d)(),this.localMatrix)}applyLocal(e,t){return Object(p.v)(t,e,this.localMatrix)}applyLocalInverse(e,t){return Object(p.v)(t,e,this.localMatrixInverse)}project(e,t){const n=new Float64Array(e.length),r=m.v.fromTypedArray(n),o=m.v.fromTypedArray(e);if(this.geographic){const e=Object(j.g)(t),a=Object(u.d)();return Object(O.d)(t,this.origin,a,e),Object(l.p)(a,a,this.localMatrix),Object(y.e)(r,o,a),Object(O.p)(n,e,0,n,t,0,n.length/3),n}const{localMatrix:a,origin:i}=this;Object(l.k)(a,u.a)?Object(x.a)(r,o):Object(y.e)(r,o,a);for(let s=0;s<n.length;s+=3)n[s+0]+=i[0],n[s+1]+=i[1],n[s+2]+=i[2];return n}getOriginPoint(e){const[t,n,r]=this.origin;return new g.a({x:t,y:n,z:r,spatialReference:e})}equals(e){return Object(i.l)(e)&&this.geographic===e.geographic&&Object(p.t)(this.origin,e.origin)&&Object(l.m)(this.localMatrix,e.localMatrix)}clone(){const e={origin:Object(h.d)(this.origin),translation:Object(h.d)(this.translation),rotation:Object(d.e)(this.rotation),scale:Object(h.d)(this.scale),geographic:this.geographic};return new r(e)}};Object(o.a)([Object(s.b)({type:[Number],nonNullable:!0,json:{write:!0}})],v.prototype,"origin",void 0),Object(o.a)([Object(s.b)({type:[Number],nonNullable:!0,json:{write:!0}})],v.prototype,"translation",void 0),Object(o.a)([Object(s.b)({type:[Number],nonNullable:!0,json:{write:!0}})],v.prototype,"rotation",void 0),Object(o.a)([Object(s.b)({type:[Number],nonNullable:!0,json:{write:!0}})],v.prototype,"scale",void 0),Object(o.a)([Object(s.b)({type:Boolean,nonNullable:!0,json:{write:!0}})],v.prototype,"geographic",void 0),Object(o.a)([Object(s.b)()],v.prototype,"localMatrix",null),Object(o.a)([Object(s.b)()],v.prototype,"localMatrixInverse",null),v=r=Object(o.a)([Object(c.a)("esri.geometry.support.MeshTransform")],v);const w=Object(f.b)(),A=v},1644:function(e,t,n){"use strict";n.r(t),n.d(t,"meshFeatureSetFromJSON",(function(){return Me}));var r=n(171),o=n(2),a=n(86),i=n(0),s=n(16),c=n(243),l=n(286),u=n(22),b=n(446),f=n(23),p=n(13),h=n(1),g=(n(17),n(12),n(10)),O=n(9),j=n(254),d=n(62),m=n(180),y=n(601),x=n(935),v=n(1245),w=n(936),A=n(420),R=n(40),F=n(1194),M=n(1222);const E=u.a.getLogger("esri.geometry.support.meshUtils.centerAt");function L(e,t,n){var r;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const a=null!=(r=null==n?void 0:n.origin)?r:e.origin;Object(o.l)(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&E.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t,n){const r=t.x-n.x,o=t.y-n.y,a=t.hasZ&&n.hasZ?t.z-n.z:0,i=e.origin;e.origin=[i[0]+r,i[1]+o,i[2]+a]}(e.transform,t,a)):Object(F.a)(e.spatialReference,n)?function(e,t,n){const r=Object(M.d)(e.vertexAttributes,n,{geographic:!0}),{position:o,normal:a,tangent:i}=Object(M.a)(r,t,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=a,e.vertexAttributes.tangent=i,e.vertexAttributesChanged()}(e,t,a):function(e,t,n){const r=k,o=P;if(Object(R.v)(t,o,e.spatialReference)){if(!Object(R.v)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,E.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}(function(e,t,n){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=t[o]-n[o]})(e.vertexAttributes.position,o,r),e.vertexAttributesChanged()}else E.error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}(e,t,a)}const P=Object(O.f)(),k=Object(O.f)();var T=n(44);function z(e){const t=Object(T.I)(e.url);return n=>{var r;const o=Object(T.E)(n,t,t),a=o?o.replace(/^ *\.\//,""):null;return null!=(r=a?e.files.get(a):null)?r:n}}async function C(e,t){return e instanceof Blob?I.fromBlob(e):"string"==typeof e?new I(e):Array.isArray(e)?async function(e,t){const n=new Map;let r=null;const a=await Object(f.h)(e.map((async e=>({name:e.name,source:await C(e instanceof Blob?e:e.source,t)})))),i=[];for(const o of a)o&&(Object(f.k)(t)?o.source.dispose():i.push(o));Object(f.q)(t);for(const{name:s,source:c}of i)(Object(o.k)(r)||/\.(gltf|glb)/i.test(s))&&(r=c.url),n.set(s,c.url),c.files&&c.files.forEach(((e,t)=>n.set(t,e)));if(Object(o.k)(r))throw new s.a("mesh-load-external:missing-files","Missing files to load external mesh source");return new I(r,(()=>i.forEach((({source:e})=>e.dispose()))),n)}(e,t):async function(e,t){const{default:r}=await Object(f.u)(Promise.resolve().then(n.bind(null,134)),t),o="string"==typeof e.multipart[0]?await Promise.all(e.multipart.map((async e=>(await r(e,{responseType:"array-buffer"})).data))):e.multipart;return I.fromBlob(new Blob(o))}(e,t)}class I{constructor(e,t=(()=>{}),n=new Map){this.url=e,this.dispose=t,this.files=n}static fromBlob(e){const t=URL.createObjectURL(e);return new I(t,(()=>URL.revokeObjectURL(t)))}}var N=n(81),S=n(118),D=n(35),B=n(5),$=n(66),G=n(607);function U(e,t,n){var r,a;e.vertexAttributes&&e.vertexAttributes.position&&(Object(o.l)(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&u.a.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t){const n=e.origin;e.origin=Object(B.j)(Object(O.f)(),n,t)}(e.transform,t)):Object(F.a)(e.spatialReference,n)?function(e,t){const n=e.spatialReference,r=e.vertexAttributes.position,a=e.vertexAttributes.normal,i=e.vertexAttributes.tangent,s=new Float64Array(r.length),c=Object(o.l)(a)?new Float32Array(a.length):null,l=Object(o.l)(i)?new Float32Array(i.length):null,u=e.extent.center,b=Z;Object(R.d)(n,[u.x,u.y,u.z],Y,Object($.g)(n)),Object(N.e)(J,Y),Object(B.C)(b,t,J),Object(G.f)(r,n,s),Object(o.l)(a)&&Object(o.l)(c)&&Object(G.c)(a,r,s,n,c),Object(o.l)(i)&&Object(o.l)(l)&&Object(G.e)(i,r,s,n,l),_(s,b),Object(G.a)(s,r,n),Object(o.l)(a)&&Object(o.l)(c)&&Object(G.b)(c,r,s,n,a),Object(o.l)(i)&&Object(o.l)(l)&&Object(G.d)(l,r,s,n,i),e.vertexAttributesChanged()}(e,t):(a=t,_((r=e).vertexAttributes.position,a),r.vertexAttributesChanged()))}function _(e,t){if(e)for(let n=0;n<e.length;n+=3)for(let r=0;r<3;r++)e[n+r]+=t[r]}const Z=Object(O.f)(),Y=Object(D.d)(),J=Object(S.b)();const V={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function W(e,t,n){e.isPlane||function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}(e),function(e,t){if(null==t)return;const n="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];K[0]=n[0],K[4]=n[1],K[8]=n[2];for(let r=0;r<e.position.length;r+=3){for(let t=0;t<3;t++)H[t]=e.position[r+t];Object(B.C)(H,H,K);for(let t=0;t<3;t++)e.position[r+t]=H[t]}if(n[0]!==n[1]||n[1]!==n[2]){K[0]=1/n[0],K[4]=1/n[1],K[8]=1/n[2];for(let t=0;t<e.normal.length;t+=3){for(let n=0;n<3;n++)H[n]=e.normal[t+n];Object(B.C)(H,H,K),Object(B.w)(H,H);for(let n=0;n<3;n++)e.normal[t+n]=H[n]}}}(e,null==n?void 0:n.size);const{vertexAttributes:r,transform:o}=Object(M.c)(e,t,n);return{vertexAttributes:new w.a({...r,uv:e.uv}),transform:o,components:[new x.a({faces:e.faces,material:n&&n.material||null})],spatialReference:t.spatialReference}}const X={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},q={south:0,east:1,north:2,west:3,up:4,down:5},H=Object(O.f)(),K=Object(S.b)();var Q=n(30);const ee=u.a.getLogger("esri.geometry.support.meshUtils.rotate");function te(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const r=e.spatialReference;if(Object(o.l)(e.transform)){var a;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&ee.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=null!=(a=null==n?void 0:n.origin)?a:e.transform.getOriginPoint(r);!function(e,t,n){const r=Object(B.B)(re,n.x,n.y,n.z),o=Object(B.k)(re,r,e.origin);e.applyLocalInverse(o,oe),e.rotation=Object(y.d)(e.rotation,t,Object(y.e)()),e.applyLocalInverse(o,o),Object(B.k)(o,o,oe),e.translation=Object(B.j)(Object(O.f)(),e.translation,o)}(e.transform,t,o)}else{var i;const r=null!=(i=null==n?void 0:n.origin)?i:e.origin;Object(F.a)(e.spatialReference,n)?function(e,t,n){const r=e.spatialReference,a=Object($.g)(r),i=ce;Object(R.v)(n,i,a)||Object(R.v)(e.origin,i,a);const s=e.vertexAttributes.position,c=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(s.length),b=Object(o.l)(c)?new Float32Array(c.length):null,f=Object(o.l)(l)?new Float32Array(l.length):null;Object(R.d)(a,i,ie,a),Object(N.e)(se,ie);const p=ae;Object(B.C)(Object(y.c)(ae),Object(y.c)(t),se),p[3]=t[3],Object(G.f)(s,r,u),Object(o.l)(c)&&Object(o.l)(b)&&Object(G.c)(c,s,u,r,b),Object(o.l)(l)&&Object(o.l)(f)&&Object(G.e)(l,s,u,r,f),ne(u,p,3,i),Object(G.a)(u,s,r),Object(o.l)(c)&&Object(o.l)(b)&&(ne(b,p,3),Object(G.b)(b,s,u,r,c)),Object(o.l)(l)&&Object(o.l)(f)&&(ne(f,p,4),Object(G.d)(f,s,u,r,l)),e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=ce;if(!Object(R.v)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,ee.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}ne(e.vertexAttributes.position,t,3,r),ne(e.vertexAttributes.normal,t,3),ne(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,r)}}function ne(e,t,n,r=O.c){if(!Object(o.k)(e)){Object(Q.g)(ie,Object(y.b)(t),Object(y.c)(t));for(let t=0;t<e.length;t+=n){for(let n=0;n<3;n++)re[n]=e[t+n]-r[n];Object(B.v)(re,re,ie);for(let n=0;n<3;n++)e[t+n]=re[n]+r[n]}}}const re=Object(O.f)(),oe=Object(O.f)(),ae=Object(y.e)(),ie=Object(D.d)(),se=Object(S.b)(),ce=Object(O.f)(),le=u.a.getLogger("esri.geometry.support.meshUtils.scale");function ue(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if(Object(o.l)(e.transform)){var a;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&le.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=null!=(a=null==n?void 0:n.origin)?a:e.transform.getOriginPoint(r);!function(e,t,n){const r=Object(B.B)(fe,n.x,n.y,n.z),o=Object(B.k)(fe,r,e.origin);e.applyLocalInverse(o,pe);const a=Object(B.p)(Object(O.f)(),e.scale,t);e.scale=a,e.applyLocalInverse(o,o),Object(B.k)(o,o,pe),e.translation=Object(B.j)(Object(O.f)(),e.translation,o)}(e.transform,t,o)}else{const r=Object(F.a)(e.spatialReference,n),a=n&&n.origin||e.origin;r?function(e,t,n){const r=e.spatialReference,a=Object($.g)(r),i=he;Object(R.v)(n,i,a)||Object(R.v)(e.origin,i,a);const s=e.vertexAttributes.position,c=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,u=new Float64Array(s.length),b=Object(o.l)(c)?new Float32Array(c.length):null,f=Object(o.l)(l)?new Float32Array(l.length):null;Object(G.f)(s,r,u),Object(o.l)(c)&&Object(o.l)(b)&&Object(G.c)(c,s,u,r,b),Object(o.l)(l)&&Object(o.l)(f)&&Object(G.e)(l,s,u,r,f),be(u,t,i),Object(G.a)(u,s,r),Object(o.l)(c)&&Object(o.l)(b)&&Object(G.b)(b,s,u,r,c),Object(o.l)(l)&&Object(o.l)(f)&&Object(G.d)(f,s,u,r,l),e.vertexAttributesChanged()}(e,t,a):function(e,t,n){const r=he;if(!Object(R.v)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,le.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}be(e.vertexAttributes.position,t,r),e.vertexAttributesChanged()}(e,t,a)}}function be(e,t,n=O.c){if(e)for(let r=0;r<e.length;r+=3){for(let t=0;t<3;t++)fe[t]=e[r+t]-n[t];Object(B.p)(fe,fe,t);for(let t=0;t<3;t++)e[r+t]=fe[t]+n[t]}}const fe=Object(O.f)(),pe=Object(O.f)(),he=Object(O.f)();var ge;const Oe="esri.geometry.Mesh";let je=ge=class extends(Object(c.b)(l.a.LoadableMixin(Object(b.b)(j.a)))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new w.a,this.type="mesh"}initialize(){(Object(o.k)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.handles.add(Object(p.f)((()=>{var e;return{vertexAttributes:this.vertexAttributes,components:null==(e=this.components)?void 0:e.map((e=>e.clone()))}}),(()=>this._set("external",null)),{once:!0,sync:!0}))}))}get hasExtent(){return!this.loaded&&Object(o.l)(this.external)&&Object(o.l)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get _boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new a.a({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new d.a({x:0,y:0,z:0,spatialReference:t})};const n=Object(o.l)(this.transform)?this.transform.project(e,t):e;let r=1/0,i=1/0,s=1/0,c=-1/0,l=-1/0,u=-1/0,b=0,f=0,p=0;const h=n.length,g=1/(h/3);let O=0;for(;O<h;){const e=n[O++],t=n[O++],o=n[O++];r=Math.min(r,e),i=Math.min(i,t),s=Math.min(s,o),c=Math.max(c,e),l=Math.max(l,t),u=Math.max(u,o),b+=g*e,f+=g*t,p+=g*o}return{extent:new a.a({xmin:r,ymin:i,zmin:s,xmax:c,ymax:l,zmax:u,spatialReference:t}),center:new d.a({x:b,y:f,z:p,spatialReference:t})}}get anchor(){if(Object(o.l)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this._boundingInfo;return new d.a({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return Object(o.l)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){return!this.loaded&&Object(o.l)(this.external)&&Object(o.l)(this.external.extent)?this.external.extent.clone():this._boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(x.a.from(e)),this.notifyChange("components")):u.a.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}u.a.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else u.a.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,n,r){return Object(y.f)(de.x,e,me),Object(y.f)(de.y,t,ye),Object(y.f)(de.z,n,xe),Object(y.d)(me,ye,me),Object(y.d)(me,xe,me),te(this,me,r),this}offset(e,t,n,r){return this.loaded?(ve[0]=e,ve[1]=t,ve[2]=n,U(this,ve,r),this):(u.a.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(ue(this,e,t),this):(u.a.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(L(this,e,t),this):(u.a.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return Object(o.l)(this.external)&&this.addResolvingPromise(async function(e,t,r){const{loadGLTFMesh:a}=await Object(f.u)(n.e(43).then(n.bind(null,1633)),r),i=await C(t,r),s=a(new d.a({x:0,y:0,z:0,spatialReference:e.spatialReference}),i.url,{resolveFile:z(i),useTransform:!0,signal:Object(o.l)(r)?r.signal:null});s.then((()=>i.dispose()),(()=>i.dispose()));const{vertexAttributes:c,components:l}=await s;e.vertexAttributes=c,e.components=l}(this,this.external.source,e)),Promise.resolve(this)}updateExternalSource(e){this._set("external",e)}clone(){let e=null;if(this.components){const t=new Map,n=new Map;e=this.components.map((e=>e.cloneWithDeduplication(t,n)))}const t={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:Object(o.l)(this.transform)?this.transform.clone():null,external:Object(o.l)(this.external)?{source:this.external.source,extent:Object(o.l)(this.external.extent)?this.external.extent.clone():null}:null};return new ge(t)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=n.e(116).then(n.bind(null,1639)),r=this.load(),o=await Promise.all([t,r]),{toBinaryGLTF:a}=o[0];return a(this,e)}static createBox(e,t){if(!(e instanceof d.a))return u.a.getLogger(Oe).error(".createBox()","expected location to be a Point instance"),null;const n=new ge(W(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=X,r=4*e.length,o=new Float64Array(3*r),a=new Float32Array(3*r),i=new Float32Array(2*r),s=new Uint32Array(2*e.length*3);let c=0,l=0,u=0,b=0;for(let f=0;f<e.length;f++){const r=e[f],p=c/3;for(const e of t)s[b++]=p+e;const h=r.corners;for(let e=0;e<4;e++){const t=h[e];let s=0;i[u++]=.25*n[e][0]+r.uvOrigin[0],i[u++]=r.uvOrigin[1]-.25*n[e][1];for(let e=0;e<3;e++)0!==r.axis[e]?(o[c++]=.5*r.axis[e],a[l++]=r.axis[e]):(o[c++]=.5*t[s++],a[l++]=0)}}return{position:o,normal:a,uv:i,faces:s}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const n=e.components[0],r=n.faces,a=q[t],i=6*a,s=new Array(6),c=new Array(r.length-6);let l=0,u=0;for(let o=0;o<r.length;o++)o>=i&&o<i+6?s[l++]=r[o]:c[u++]=r[o];if(Object(o.l)(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),n=4*a*2,r=[0,1,1,1,1,0,0,0];for(let e=0;e<r.length;e++)t[n+e]=r[e];e.vertexAttributes.uv=t}return e.components=[new x.a({faces:s,material:n.material}),new x.a({faces:c})],e}(n,t.imageFace):n}static createSphere(e,t){return e instanceof d.a?new ge(W(function(e=0){const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),a=new Float32Array(3*r),i=new Float32Array(2*r),s=new Uint32Array((t-1)*n*2*3);let c=0,l=0,u=0,b=0;for(let f=0;f<=t;f++){const e=f/t*Math.PI+.5*Math.PI,r=Math.cos(e),p=Math.sin(e);H[2]=p;const h=0===f||f===t,g=h?n-1:n;for(let O=0;O<=g;O++){const e=O/g*2*Math.PI;H[0]=-Math.sin(e)*r,H[1]=Math.cos(e)*r;for(let t=0;t<3;t++)o[c]=.5*H[t],a[c]=H[t],++c;i[l++]=(O+(h?.5:0))/n,i[l++]=f/t,0!==f&&O!==n&&(f!==t&&(s[u++]=b,s[u++]=b+1,s[u++]=b-n),1!==f&&(s[u++]=b,s[u++]=b-n,s[u++]=b-n-1)),b++}}return{position:o,normal:a,uv:i,faces:s}}(t&&t.densificationFactor||0),e,t)):(u.a.getLogger(Oe).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof d.a?new ge(W(function(e=0){const t=Math.round(16*2**e),n=4*(t+1)+2*t,r=new Float64Array(3*n),o=new Float32Array(3*n),a=new Float32Array(2*n),i=new Uint32Array(4*t*3);let s=0,c=0,l=0,u=0,b=0;for(let f=0;f<=5;f++){const e=0===f||5===f,n=f<=1||f>=4,p=2===f||4===f,h=e?t-1:t;for(let g=0;g<=h;g++){const O=g/h*2*Math.PI,j=e?0:.5;H[0]=j*Math.sin(O),H[1]=j*-Math.cos(O),H[2]=f<=2?.5:-.5;for(let e=0;e<3;e++)r[s++]=H[e],o[c++]=n?2===e?f<=1?1:-1:0:2===e?0:H[e]/j;a[l++]=(g+(e?.5:0))/t,a[l++]=f<=1?1*f/3:f<=3?1*(f-2)/3+1/3:1*(f-4)/3+2/3,p||0===f||g===t||(5!==f&&(i[u++]=b,i[u++]=b+1,i[u++]=b-t),1!==f&&(i[u++]=b,i[u++]=b-t,i[u++]=b-t-1)),b++}}return{position:r,normal:o,uv:a,faces:i}}(t&&t.densificationFactor||0),e,t)):(u.a.getLogger(Oe).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){var n;if(!(e instanceof d.a))return u.a.getLogger(Oe).error(".createPlane()","expected location to be a Point instance"),null;const r=null!=(n=null==t?void 0:t.facing)?n:"up",o=function(e,t){const n="number"==typeof t?t:null!=t?t.width:1,r="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}(r,null==t?void 0:t.size);return new ge(W(function(e){const t=V.facingAxisOrderSwap[e],n=V.position,r=V.normal,o=new Float64Array(n.length),a=new Float32Array(r.length);let i=0;for(let s=0;s<4;s++){const e=i;for(let s=0;s<3;s++){const c=t[s],l=Math.abs(c)-1,u=c>=0?1:-1;o[i]=n[e+l]*u,a[i]=r[e+l]*u,i++}}return{position:o,normal:a,uv:new Float32Array(V.uv),faces:new Uint32Array(V.faces),isPlane:!0}}(r),e,{...t,size:o}))}static createFromPolygon(e,t){var n;if(!(e instanceof m.a))return u.a.getLogger(Oe).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const r=Object(A.c)(e);return new ge({vertexAttributes:new w.a({position:r.position}),components:[new x.a({faces:r.faces,shading:"flat",material:null!=(n=null==t?void 0:t.material)?n:null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,t,r){if(!(e instanceof d.a))throw u.a.getLogger(Oe).error(".createfromGLTF()","expected location to be a Point instance"),new s.a("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await Object(f.u)(n.e(43).then(n.bind(null,1633)),r);return new ge(await o(e,t,r))}static createWithExternalSource(e,t,n){var r,o,a,i;const s=null!=(r=null==n?void 0:n.extent)?r:null,c=null!=(o=null==n||null==(a=n.transform)?void 0:a.clone())?o:new v.a;c.origin=[e.x,e.y,null!=(i=e.z)?i:0];const l=e.spatialReference;return new ge({external:{source:t,extent:s},transform:c,spatialReference:l})}static createIncomplete(e,t){var n,r,o;const a=null!=(n=null==t||null==(r=t.transform)?void 0:r.clone())?n:new v.a;a.origin=[e.x,e.y,null!=(o=e.z)?o:0];const i=e.spatialReference,c=new ge({transform:a,spatialReference:i});return c.addResolvingPromise(Promise.reject(new s.a("mesh-incomplete","Mesh resources are not complete"))),c}};Object(i.a)([Object(h.b)({type:[x.a],json:{write:!0}})],je.prototype,"components",void 0),Object(i.a)([Object(h.b)({type:v.a,json:{write:!0}})],je.prototype,"transform",void 0),Object(i.a)([Object(h.b)({constructOnly:!0})],je.prototype,"external",void 0),Object(i.a)([Object(h.b)({readOnly:!0})],je.prototype,"hasExtent",null),Object(i.a)([Object(h.b)({readOnly:!0})],je.prototype,"_boundingInfo",null),Object(i.a)([Object(h.b)({readOnly:!0})],je.prototype,"anchor",null),Object(i.a)([Object(h.b)({readOnly:!0})],je.prototype,"origin",null),Object(i.a)([Object(h.b)({readOnly:!0,json:{read:!1}})],je.prototype,"extent",null),Object(i.a)([Object(h.b)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],je.prototype,"hasZ",void 0),Object(i.a)([Object(h.b)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],je.prototype,"hasM",void 0),Object(i.a)([Object(h.b)({type:w.a,nonNullable:!0,json:{write:!0}})],je.prototype,"vertexAttributes",void 0),je=ge=Object(i.a)([Object(g.a)(Oe)],je);const de={x:Object(O.h)(1,0,0),y:Object(O.h)(0,1,0),z:Object(O.h)(0,0,1)},me=Object(y.e)(),ye=Object(y.e)(),xe=Object(y.e)(),ve=Object(O.f)(),we=je;var Ae,Re,Fe=n(474);function Me(e,t,n){const a=n.features;n.features=[],delete n.geometryType;const i=Fe.default.fromJSON(n);if(i.geometryType="mesh",!n.assetMaps)return i;const s=function(e,t){const n=new Map;for(const r of t){const e=r.parentGlobalId;if(null==e)continue;const t=r.assetName,o=r.assetURL,a=r.conversionStatus;let i=n.get(e);if(null!=i)throw new Error("multiple asset parts not expected.");switch(i={name:t,status:Ae.FAILED,url:o,geographic:Le(r.flags).projectVertices},n.set(e,i),a){case"COMPLETED":case"SUBMITTED":i.status=Ae.COMPLETED;break;case"INPROGRESS":i.status=Ae.PENDING;break;default:i.status=Ae.FAILED}}return n}(0,n.assetMaps),c=i.spatialReference,l=n.globalIdFieldName,u=Object(o.k)(e.outFields)||!e.outFields.length?()=>({}):(b=e.outFields.includes("*")?null:new Set(e.outFields),({attributes:e})=>{if(!e)return{};if(!b)return e;for(const t in e)b.has(t)||delete e[t];return e});var b;for(const f of a){const e=Ee(f,l,c,t,s);Object(o.l)(e)&&i.features.push(new r.a({geometry:e,attributes:u(f)}))}return i}function Ee(e,t,n,r,o){const i=e.attributes[t],s=o.get(i);if(null==s||s.status===Ae.FAILED||null==s.url)return null;const c=function({attributes:e},t,{transformFieldRoles:n}){return new d.a({x:e[n.originX],y:e[n.originY],z:e[n.originZ],spatialReference:t})}(e,n,r),l=a.a.fromJSON(e.geometry);l.spatialReference=n;const u=function(e,{transformFieldRoles:t},n){return new v.a({translation:[e[t.translationX],e[t.translationY],e[t.translationZ]],rotation:Object(y.f)([e[t.rotationX],e[t.rotationY],e[t.rotationZ]],e[t.rotationDeg]),scale:[e[t.scaleX],e[t.scaleY],e[t.scaleZ]],geographic:n})}(e.attributes,r,s.geographic);return s.status===Ae.PENDING?we.createIncomplete(c,{extent:l,transform:u}):we.createWithExternalSource(c,[{name:s.name,source:s.url}],{extent:l,transform:u})}function Le(e){return{projectVertices:e.includes("PROJECT_VERTICES")}}(Re=Ae||(Ae={}))[Re.FAILED=0]="FAILED",Re[Re.PENDING=1]="PENDING",Re[Re.COMPLETED=2]="COMPLETED"}}]);
//# sourceMappingURL=89.bd49fc34.chunk.js.map