(this["webpackJsonppopulation-arcgis"]=this["webpackJsonppopulation-arcgis"]||[]).push([[0],{1132:function(e,t,i){"use strict";i.d(t,"a",(function(){return n}));var r=i(2);function s(e,t){return e?t?4:3:t?3:2}function n(e,t,i,n,u){if(Object(r.k)(t)||!t.lengths.length)return null;const o="upperLeft"===(null==u?void 0:u.originPosition)?-1:1;e.lengths.length&&(e.lengths.length=0),e.coords.length&&(e.coords.length=0);const l=e.coords,h=[],f=i?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:d,coords:p}=t,y=s(i,n);let m=0;for(const r of d){const e=a(f,p,m,r,i,n,o);e&&h.push(e),m+=r*y}if(h.sort(((e,t)=>{let r=o*e[2]-o*t[2];return 0===r&&i&&(r=e[4]-t[4]),r})),h.length){let e=6*h[0][2];l[0]=h[0][0]/e,l[1]=h[0][1]/e,i&&(e=6*h[0][4],l[2]=0!==e?h[0][3]/e:0),(l[0]<f[0]||l[0]>f[1]||l[1]<f[2]||l[1]>f[3]||i&&(l[2]<f[4]||l[2]>f[5]))&&(l.length=0)}if(!l.length){const e=t.lengths[0]?c(p,0,d[0],i,n):null;if(!e)return null;l[0]=e[0],l[1]=e[1],i&&e.length>2&&(l[2]=e[2])}return e}function a(e,t,i,r,n,a,c=1){const u=s(n,a);let o=i,l=i+u,h=0,f=0,d=0,p=0,y=0;for(let s=0,g=r-1;s<g;s++,o+=u,l+=u){const i=t[o],r=t[o+1],s=t[o+2],a=t[l],c=t[l+1],u=t[l+2];let m=i*c-a*r;p+=m,h+=(i+a)*m,f+=(r+c)*m,n&&(m=i*u-a*s,d+=(s+u)*m,y+=m),i<e[0]&&(e[0]=i),i>e[1]&&(e[1]=i),r<e[2]&&(e[2]=r),r>e[3]&&(e[3]=r),n&&(s<e[4]&&(e[4]=s),s>e[5]&&(e[5]=s))}if(p*c>0&&(p*=-1),y*c>0&&(y*=-1),!p)return null;const m=[h,f,.5*p];return n&&(m[3]=d,m[4]=.5*y),m}function c(e,t,i,r,n){const a=s(r,n);let c=t,f=t+a,d=0,p=0,y=0,m=0;for(let s=0,g=i-1;s<g;s++,c+=a,f+=a){const t=e[c],i=e[c+1],s=e[c+2],n=e[f],a=e[f+1],g=e[f+2],b=r?o(t,i,s,n,a,g):u(t,i,n,a);if(b)if(d+=b,r){const e=h(t,i,s,n,a,g);p+=b*e[0],y+=b*e[1],m+=b*e[2]}else{const e=l(t,i,n,a);p+=b*e[0],y+=b*e[1]}}return d>0?r?[p/d,y/d,m/d]:[p/d,y/d]:i>0?r?[e[t],e[t+1],e[t+2]]:[e[t],e[t+1]]:null}function u(e,t,i,r){const s=i-e,n=r-t;return Math.sqrt(s*s+n*n)}function o(e,t,i,r,s,n){const a=r-e,c=s-t,u=n-i;return Math.sqrt(a*a+c*c+u*u)}function l(e,t,i,r){return[e+.5*(i-e),t+.5*(r-t)]}function h(e,t,i,r,s,n){return[e+.5*(r-e),t+.5*(s-t),i+.5*(n-i)]}},1133:function(e,t,i){"use strict";i.d(t,"a",(function(){return c}));var r,s,n,a={exports:{}};r=a,s=function(){function e(i,r,s,n,a){for(;n>s;){if(n-s>600){var c=n-s+1,u=r-s+1,o=Math.log(c),l=.5*Math.exp(2*o/3),h=.5*Math.sqrt(o*l*(c-l)/c)*(u-c/2<0?-1:1);e(i,r,Math.max(s,Math.floor(r-u*l/c+h)),Math.min(n,Math.floor(r+(c-u)*l/c+h)),a)}var f=i[r],d=s,p=n;for(t(i,s,r),a(i[n],f)>0&&t(i,s,n);d<p;){for(t(i,d,p),d++,p--;a(i[d],f)<0;)d++;for(;a(i[p],f)>0;)p--}0===a(i[s],f)?t(i,s,p):t(i,++p,n),p<=r&&(s=p+1),r<=p&&(n=p-1)}}function t(e,t,i){var r=e[t];e[t]=e[i],e[i]=r}function i(e,t){return e<t?-1:e>t?1:0}return function(t,r,s,n,a){e(t,r,s||0,n||t.length-1,a||i)}},void 0!==(n=s())&&(r.exports=n);const c=a.exports},1151:function(e,t,i){"use strict";i.d(t,"a",(function(){return E}));var r=i(17),s=i(16),n=i(25),a=i(2),c=i(460),u=i(68),o=i(39),l=i(37),h=i(726),f=i(122),d=i(675),p=i(47),y=i(336),m=i(590),g=i(511),b=i(1004),_=i(883),O=i(1489),S=i(1437),x=i(496),j=i(900),I=i(245),w=i(124);const R="feature-store:unsupported-query";const F=new c.c(2e6);let Q=0;class E{constructor(e){this.capabilities={query:b.a},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new c.b(Q+++"$$",F)),this.fieldsIndex=new j.a(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=Object(a.s)(this._frameTask),this.clearCache(),Object(a.e)(this._geometryQueryCache),this._changeHandle=Object(a.s)(this._changeHandle),Object(a.e)(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return Object(a.k)(e)?null:{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:Object(x.b)(this.spatialReference)}}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=Object(S.a)(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){var e;null!=(e=this._geometryQueryCache)&&e.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e,t){try{return(await this._executeQuery(e,{},t)).createQueryResponse()}catch(i){if(i!==x.a)throw i;return new _.a([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(i){if(i!==x.a)throw i;return 0}}async executeQueryForExtent(e,t){const i=e.outSR;try{const r=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),s=r.size;if(!s)return{count:0,extent:null};Object(o.A)(N,o.a),this.featureStore.forEachBounds(r.items,(e=>Object(o.m)(N,e)),T);const n={xmin:N[0],ymin:N[1],xmax:N[3],ymax:N[4],spatialReference:Object(x.b)(this.spatialReference)};this.hasZ&&isFinite(N[2])&&isFinite(N[5])&&(n.zmin=N[2],n.zmax=N[5]);const a=Object(g.b)(n,r.spatialReference,i);if(a.spatialReference=Object(x.b)(i||this.spatialReference),a.xmax-a.xmin==0){const e=Object(u.f)(a.spatialReference);a.xmin-=e,a.xmax+=e}if(a.ymax-a.ymin==0){const e=Object(u.f)(a.spatialReference);a.ymin-=e,a.ymax+=e}if(this.hasZ&&null!=a.zmin&&null!=a.zmax&&a.zmax-a.zmin==0){const e=Object(u.f)(a.spatialReference);a.zmin-=e,a.zmax+=e}return{count:s,extent:a}}catch(r){if(r===x.a)return{count:0,extent:null};throw r}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=i.items,s=new Set;return await this._reschedule((()=>{for(const e of r)s.add(i.featureAdapter.getObjectId(e))}),t),s}catch(i){if(i===x.a)return new Set;throw i}}async executeQueryForSnapping(e,t){const{point:i,distance:r,types:s}=e;if(s===_.b.NONE)return{candidates:[]};const n=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),c=!Object(p.d)(i.spatialReference,this.spatialReference);c&&await Object(g.a)(i.spatialReference,this.spatialReference);const u="number"==typeof r?r:r.x,o="number"==typeof r?r:r.y,l={xmin:i.x-u,xmax:i.x+u,ymin:i.y-o,ymax:i.y+o,spatialReference:i.spatialReference},h=c?Object(g.b)(l,this.spatialReference):l;if(!h)return{candidates:[]};const y=(await Object(d.a)(Object(f.a)(i),null,{signal:t}))[0],m=(await Object(d.a)(Object(f.a)(h),null,{signal:t}))[0];if(Object(a.k)(y)||Object(a.k)(m))return{candidates:[]};const b=new _.a(this._searchFeatures(this._getQueryBBoxes(m.toJSON())),n,this);await this._reschedule((()=>this._executeObjectIdsQuery(b)),t),await this._reschedule((()=>this._executeTimeQuery(b)),t),await this._reschedule((()=>this._executeAttributesQuery(b)),t);const O=y.toJSON(),S=c?Object(g.b)(O,this.spatialReference):O,x=c?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:r;return b.createSnappingResponse({...e,point:S,distance:x},i.spatialReference)}async executeQueryForLatestObservations(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new s.a(R,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},t);return await this._reschedule((()=>this._filterLatest(i)),t),i.createQueryResponse()}catch(i){if(i!==x.a)throw i;return new _.a([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const{field:r,normalizationField:s,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:r,normalizationField:s,valueExpression:n},i)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const{field:r,field2:s,field3:n,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:r,field2:s,field3:n,valueExpression:a},i)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const{field:r,normalizationField:s,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:r,normalizationField:s,valueExpression:n},i)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const{field:r,normalizationField:s,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:r,normalizationField:s,valueExpression:n},i)).createHistogramResponse(t)}async _schedule(e,t){return Object(a.l)(this._frameTask)?this._frameTask.schedule(e,t):e(w.d)}async _reschedule(e,t){return Object(a.l)(this._frameTask)?this._frameTask.reschedule(e,t):e(w.d)}_getAll(e){return Object(a.k)(this._allItems)&&(this._allItems=this.featureStore.toArray()),new _.a(this._allItems,e,this)}async _executeQuery(e,t,i){e=Object(n.a)(e),e=await this._schedule((()=>Object(x.d)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),e={...e,...t};const r=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),s=await this._reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(s)),i),await this._reschedule((()=>this._executeObjectIdsQuery(s)),i),await this._reschedule((()=>this._executeTimeQuery(s)),i),await this._reschedule((()=>this._executeAttributesQuery(s)),i),s}async _executeSceneFilterQuery(e,t){if(Object(a.k)(e.sceneFilter))return null;const{outSR:i,returnGeometry:r,returnCentroid:s}=e,n=this.featureStore.featureSpatialReference,c=e.sceneFilter.geometry,u=Object(a.k)(n)||Object(p.d)(n,c.spatialReference)?c:Object(g.b)(c,n);if(!u)return null;const o=r||s,l=Object(p.l)(i)&&!Object(p.d)(this.spatialReference,i)&&o?async e=>this._project(e,i):e=>e,h=this.featureAdapter,f=this._searchFeatures(this._getQueryBBoxes(u));if("disjoint"===e.sceneFilter.spatialRelationship){if(!f.length)return null;const i=new Set;for(const e of f)i.add(h.getObjectId(e));const r=await this._reschedule((()=>this.featureStore.toArray()),t);return l(await this._reschedule((async()=>{const s=await Object(O.c)("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),n=await this._runSpatialFilter(r,(e=>!i.has(h.getObjectId(e))||s(h.getGeometry(e))),t);return new _.a(n,e,this)}),t))}if(!f.length)return new _.a([],e,this);if(this._canExecuteSinglePass(u,e))return l(new _.a(f,e,this));const d=await Object(O.c)("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),y=await this._runSpatialFilter(f,(e=>d(h.getGeometry(e))),t);return l(new _.a(y,e,this))}async _executeGeometryQuery(e,t,i){if(Object(a.l)(t)&&0===t.items.length)return t;e=Object(a.l)(t)?t.query:e;const{geometry:s,outSR:n,spatialRel:c,returnGeometry:u,returnCentroid:o}=e,l=this.featureStore.featureSpatialReference,h=!s||Object(a.k)(l)||Object(p.d)(l,s.spatialReference)?s:Object(g.b)(s,l),f=u||o,d=Object(p.l)(n)&&!Object(p.d)(this.spatialReference,n),y=this._geometryQueryCache&&Object(a.k)(t)?d&&f?JSON.stringify({originalFilterGeometry:s,spatialRelationship:c,outSpatialReference:n}):JSON.stringify({originalFilterGeometry:s,spatialRelationship:c}):null,m=y?this._geometryQueryCache.get(y):null;if(Object(a.l)(m))return new _.a(m,e,this);const b=async e=>(d&&f&&await this._project(e,n),y&&this._geometryQueryCache.put(y,e.items,e.items.length+1),e);if(!h)return b(Object(a.l)(t)?t:this._getAll(e));const S=this.featureAdapter;let x=this._searchFeatures(this._getQueryBBoxes(s));if("esriSpatialRelDisjoint"===c){if(!x.length)return b(Object(a.l)(t)?t:this._getAll(e));const r=new Set;for(const e of x)r.add(S.getObjectId(e));const s=Object(a.l)(t)?t.items:await this._reschedule((()=>this.featureStore.toArray()),i),n=await this._reschedule((async()=>{const t=await Object(O.c)(c,h,this.geometryType,this.hasZ,this.hasM),n=await this._runSpatialFilter(s,(e=>!r.has(S.getObjectId(e))||t(S.getGeometry(e))),i);return new _.a(n,e,this)}),i);return b(n)}if(Object(a.l)(t)){const e=new r.a;x=x.filter((i=>Object(r.g)(t.items,i,t.items.length,e)>=0))}if(!x.length){const t=new _.a([],e,this);return y&&this._geometryQueryCache.put(y,t.items,1),t}if(this._canExecuteSinglePass(h,e))return b(new _.a(x,e,this));const j=await Object(O.c)(c,h,this.geometryType,this.hasZ,this.hasM),I=await this._runSpatialFilter(x,(e=>j(S.getGeometry(e))),i);return b(new _.a(I,e,this))}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds||!e.query.aggregateIds.length||Object(a.k)(this.aggregateAdapter))return;const t=new Set;for(const r of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(r).forEach((e=>t.add(e)));const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const t=Object(S.b)(this.timeInfo,e.query.timeExtent,this.featureAdapter);Object(a.k)(t)||(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=Object(m.c)(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,t,i){if(!t)return e;if(Object(a.k)(this._frameTask))return e.filter((e=>t(e)));let r=0;const s=new Array,n=async a=>{for(;r<e.length;){const c=e[r++];t(c)&&(s.push(c),a.madeProgress()),a.done&&await this._reschedule((e=>n(e)),i)}};return this._reschedule((e=>n(e)),i).then((()=>s))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:r}=this.timeInfo,s=r||i,n=new Map,a=this.featureAdapter.getAttribute;for(const c of e.items){const e=a(c,t),i=a(c,s),r=n.get(e);(!r||i>a(r,s))&&n.set(e,c)}e.items=Array.from(n.values())}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return Object(O.a)(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i||"esriSpatialRelWithin"===i))}async _project(e,t){if(!t||Object(p.d)(this.spatialReference,t))return e;const i=this.featureAdapter,r=await Object(g.c)(e.items.map((e=>Object(x.c)(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t);return e.items=r.map(((t,r)=>i.cloneWithGeometry(e.items[r],Object(y.d)(t,this.hasZ,this.hasM)))),e}_getQueryBBoxes(e){if(Object(O.a)(e)){if(Object(f.d)(e))return[Object(l.u)(e.xmin,e.ymin,e.xmax,e.ymax)];if(Object(f.g)(e))return e.rings.map((e=>Object(l.u)(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[Object(h.a)(Object(l.m)(),e)]}_searchFeatures(e){for(const i of e)this.featureStore.forEachInBounds(i,(e=>A.add(e)));const t=Array.from(A.values());return A.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new s.a(R,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t),Object(O.b)(e,this.geometryType,this.spatialReference),Object(g.a)(this.spatialReference,e.outSR)]).then((()=>e))}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i}=await Object(I.e)();t=i.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.field2&&t.push(e.field2),e.field3&&t.push(e.field3),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new s.a(R,"params should have at least a field or valueExpression",{params:e});Object(m.e)(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new s.a(R,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([Object(O.b)(e,this.geometryType,this.spatialReference),Object(g.a)(this.spatialReference,e.outSR)]).then((()=>e))}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:i,returnDistinctValues:r,outStatistics:n}=e,a=n?n.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(i&&i.length>0){const e=" asc",t=" desc",r=i.map((i=>{const r=i.toLowerCase();return r.includes(e)?r.split(e)[0]:r.includes(t)?r.split(t)[0]:i})).filter((e=>!a.includes(e)));Object(m.e)(this.fieldsIndex,r,"orderByFields contains missing fields")}if(t&&t.length>0)Object(m.e)(this.fieldsIndex,t,"outFields contains missing fields");else if(r)throw new s.a(R,"outFields should be specified for returnDistinctValues",{query:e});Object(m.g)(this.fieldsIndex,e.where)}_checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:r}=e,n=i&&i.length,a=t&&t.length;if(r){if(!n||!a)throw new s.a(R,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});Object(m.f)(this.fieldsIndex,r,t)}if(a){if(!function(e){return e.every((e=>"exceedslimit"!==e.statisticType))}(t))return;const r=t.map((e=>e.onStatisticField)).filter(Boolean);Object(m.e)(this.fieldsIndex,r,"onStatisticFields contains missing fields"),n&&Object(m.e)(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const i of t){const{onStatisticField:t,statisticType:r}=i;if("percentile_disc"!==r&&"percentile_cont"!==r||!("statisticParameters"in i)){if("count"!==r&&t&&Object(m.d)(t,this.fieldsIndex))throw new s.a(R,"outStatistics contains non-numeric fields",{definition:i,query:e})}else{const{statisticParameters:t}=i;if(!t)throw new s.a(R,"statisticParamters should be set for percentile type",{definition:i,query:e})}}}}async _getQueryEngineResultForStats(e,t,i){e=Object(n.a)(e);try{e=await this._schedule((()=>Object(x.d)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkStatisticsSupport(e,t)),i);const r=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),s=await this._reschedule((()=>this._executeGeometryQuery(e,r,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(s)),i),await this._reschedule((()=>this._executeObjectIdsQuery(s)),i),await this._reschedule((()=>this._executeTimeQuery(s)),i),await this._reschedule((()=>this._executeAttributesQuery(s)),i),s}catch(r){if(r!==x.a)throw r;return new _.a([],e,this)}}}const T=Object(o.h)(),N=Object(o.h)(),A=new Set},1437:function(e,t,i){"use strict";function r(e,t){if(!e)return null;const i=t.featureAdapter,{startTimeField:r,endTimeField:s}=e;let n=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(r&&s)t.forEach((e=>{const t=i.getAttribute(e,r),c=i.getAttribute(e,s);null==t||isNaN(t)||(n=Math.min(n,t)),null==c||isNaN(c)||(a=Math.max(a,c))}));else{const e=r||s;t.forEach((t=>{const r=i.getAttribute(t,e);null==r||isNaN(r)||(n=Math.min(n,r),a=Math.max(a,r))}))}return{start:n,end:a}}function s(e,t,i){if(!t||!e)return null;const{startTimeField:r,endTimeField:s}=e;if(!r&&!s)return null;const{start:n,end:a}=t;return null===n&&null===a?null:void 0===n&&void 0===a?()=>!1:r&&s?function(e,t,i,r,s){return null!=r&&null!=s?n=>{const a=e.getAttribute(n,t),c=e.getAttribute(n,i);return(null==a||a<=s)&&(null==c||c>=r)}:null!=r?t=>{const s=e.getAttribute(t,i);return null==s||s>=r}:null!=s?i=>{const r=e.getAttribute(i,t);return null==r||r<=s}:void 0}(i,r,s,n,a):function(e,t,i,r){return null!=i&&null!=r&&i===r?r=>e.getAttribute(r,t)===i:null!=i&&null!=r?s=>{const n=e.getAttribute(s,t);return n>=i&&n<=r}:null!=i?r=>e.getAttribute(r,t)>=i:null!=r?i=>e.getAttribute(i,t)<=r:void 0}(i,r||s,n,a)}i.d(t,"a",(function(){return r})),i.d(t,"b",(function(){return s}))},1489:function(e,t,i){"use strict";i.d(t,"a",(function(){return x})),i.d(t,"b",(function(){return S})),i.d(t,"c",(function(){return O}));var r=i(16),s=i(301),n=i(725);var a=i(122),c=i(47);function u(e,t){return e?t?4:3:t?3:2}function o(e,t,i,r,s){if(!e)return!1;const n=u(t,i),{coords:a,lengths:c}=e;let o=!1,h=0;for(const u of c)o=l(o,a,n,h,u,r,s),h+=u*n;return o}function l(e,t,i,r,s,n,a){let c=e,u=r;for(let o=r,l=r+s*i;o<l;o+=i){u=o+i,u===l&&(u=r);const e=t[o],s=t[o+1],h=t[u],f=t[u+1];(s<a&&f>=a||f<a&&s>=a)&&e+(a-s)/(f-s)*(h-e)<n&&(c=!c)}return c}var h=i(336),f=i(295),d=i(511),p=i(496);const y="feature-store:unsupported-query",m={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},g={esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},b={esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},_={esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1};function O(e,t,r,c,l){if(Object(a.g)(t)&&"esriGeometryPoint"===r&&("esriSpatialRelIntersects"===e||"esriSpatialRelContains"===e)){const e=Object(h.f)(new f.a,t,!1,!1);return Promise.resolve((t=>function(e,t,i,r){return o(e,t,i,r.coords[0],r.coords[1])}(e,!1,!1,t)))}if(Object(a.g)(t)&&"esriGeometryMultipoint"===r){const i=Object(h.f)(new f.a,t,!1,!1);if("esriSpatialRelContains"===e)return Promise.resolve((e=>function(e,t,i,r,s,n){const a=u(s,n),{coords:c,lengths:l}=r;if(!l)return!1;for(let u=0,h=0;u<l.length;u++,h+=a)if(!o(e,t,i,c[h],c[h+1]))return!1;return!0}(i,!1,!1,e,c,l)))}if(Object(a.d)(t)&&"esriGeometryPoint"===r&&("esriSpatialRelIntersects"===e||"esriSpatialRelContains"===e))return Promise.resolve((e=>Object(s.e)(t,Object(p.c)(r,c,l,e))));if(Object(a.d)(t)&&"esriGeometryMultipoint"===r&&"esriSpatialRelContains"===e)return Promise.resolve((e=>Object(s.d)(t,Object(p.c)(r,c,l,e))));if(Object(a.d)(t)&&"esriSpatialRelIntersects"===e){const e=function(e){return"mesh"===e?n.a:Object(n.b)(e)}(r);return Promise.resolve((i=>e(t,Object(p.c)(r,c,l,i))))}return i.e(9).then(i.bind(null,1030)).then((i=>{const s=i[m[e]].bind(null,t.spatialReference,t);return e=>s(Object(p.c)(r,c,l,e))}))}async function S(e,t,i){const{spatialRel:s,geometry:n}=e;if(n){if(null==(u=s)||!0!==g[u])throw new r.a(y,"Unsupported query spatial relationship",{query:e});if(Object(c.l)(n.spatialReference)&&Object(c.l)(i)){if(!function(e){return null!=e&&!0===b[Object(a.c)(e)]}(n))throw new r.a(y,"Unsupported query geometry type",{query:e});if(!function(e){return null!=e&&!0===_[e]}(t))throw new r.a(y,"Unsupported layer geometry type",{query:e});if(e.outSR)return Object(d.a)(e.geometry&&e.geometry.spatialReference,e.outSR)}}var u}function x(e){if(Object(a.d)(e))return!0;if(Object(a.g)(e)){for(const t of e.rings){if(5!==t.length)return!1;if(t[0][0]!==t[1][0]||t[0][0]!==t[4][0]||t[2][0]!==t[3][0]||t[0][1]!==t[3][1]||t[0][1]!==t[4][1]||t[1][1]!==t[2][1])return!1}return!0}return!1}}}]);
//# sourceMappingURL=0.11971aee.chunk.js.map