(this["webpackJsonppopulation-arcgis"]=this["webpackJsonppopulation-arcgis"]||[]).push([[196],{1081:function(e,a,i){"use strict";i.r(a),i.d(a,"classBreaks",(function(){return b})),i.d(a,"heatmapStatistics",(function(){return x})),i.d(a,"histogram",(function(){return I})),i.d(a,"summaryStatistics",(function(){return p})),i.d(a,"uniqueValues",(function(){return v}));i(167),i(16);var n=i(2),t=i(31),o=i(57),l=i(391),r=i(47),s=(i(99),i(762)),u=i(293),c=i(245),f=i(62);let m=null;async function d(e,a){if(!a)return[];const{field:i,field2:n,field3:t,fieldDelimiter:l}=e,r=e.valueExpression,s=e.normalizationType,f=e.normalizationField,d=e.normalizationTotal,p=[],v=e.viewInfoParams;let b=null,I=null;if(r){if(!m){const{arcadeUtils:e}=await Object(c.e)();m=e}b=m.createFunction(r),I=v&&m.getViewInfo({viewingMode:v.viewingMode,scale:v.scale,spatialReference:new o.a(v.spatialReference)})}const x=e.fieldInfos,z=a[0]&&"declaredClass"in a[0]&&"esri.Graphic"===a[0].declaredClass||!x?null:{fields:x};return a.forEach((e=>{const a=e.attributes;let o;if(r){const a=z?{...e,layer:z}:e,i=m.createExecContext(a,I);o=m.executeFunction(b,i)}else a&&(o=a[i],n&&(o=`${Object(u.k)(o)}${l}${Object(u.k)(a[n])}`,t&&(o=`${o}${l}${Object(u.k)(a[t])}`)));if(s&&"number"==typeof o&&isFinite(o)){const e=a&&parseFloat(a[f]);o=Object(u.i)(o,s,e,d)}p.push(o)})),p}async function p(e){const{attribute:a,features:i}=e,{normalizationType:n,normalizationField:t,minValue:o,maxValue:l,fieldType:r}=a,s=await d({field:a.field,valueExpression:a.valueExpression,normalizationType:n,normalizationField:t,normalizationTotal:a.normalizationTotal,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i),c=Object(u.j)({normalizationType:n,normalizationField:t,minValue:o,maxValue:l}),f={value:.5,fieldType:r},m="esriFieldTypeString"===r?Object(u.e)({values:s,supportsNullCount:c,percentileParams:f}):Object(u.d)({values:s,minValue:o,maxValue:l,useSampleStdDev:!n,supportsNullCount:c,percentileParams:f});return Object(u.l)(m,"esriFieldTypeDate"===r)}async function v(e){const{attribute:a,features:i}=e,n=await d({field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:a.fieldDelimiter,valueExpression:a.valueExpression,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i),t=Object(u.f)(n);return Object(u.g)(t,a.domains,a.returnAllCodedValues,a.fieldDelimiter)}async function b(e){const{attribute:a,features:i}=e,{field:n,normalizationType:t,normalizationField:o,normalizationTotal:l,classificationMethod:r}=a,s=await d({field:n,valueExpression:a.valueExpression,normalizationType:t,normalizationField:o,normalizationTotal:l,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i),c=Object(u.a)(s,{field:n,normalizationType:t,normalizationField:o,normalizationTotal:l,classificationMethod:r,standardDeviationInterval:a.standardDeviationInterval,numClasses:a.numClasses,minValue:a.minValue,maxValue:a.maxValue});return Object(u.m)(c,r)}async function I(e){const{attribute:a,features:i}=e,{field:n,normalizationType:t,normalizationField:o,normalizationTotal:l,classificationMethod:r}=a,s=await d({field:n,valueExpression:a.valueExpression,normalizationType:t,normalizationField:o,normalizationTotal:l,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i);return Object(u.b)(s,{field:n,normalizationType:t,normalizationField:o,normalizationTotal:l,classificationMethod:r,standardDeviationInterval:a.standardDeviationInterval,numBins:a.numBins,minValue:a.minValue,maxValue:a.maxValue})}async function x(e){const{attribute:a,features:i}=e,{field:o,radius:u,fieldOffset:c,transform:m,spatialReference:d,size:p}=a,v=function(e,a,i,t){const o=Object(r.q)(i)?Object(r.e)(i):null,s=o?Math.round((o.valid[1]-o.valid[0])/a.scale[0]):null;return e.map((e=>{const i=new f.a(Object(n.t)(e.geometry));return Object(l.a)(a,i,i,i.hasZ,i.hasM),e.geometry=o?function(e,a,i){return e.x<0?e.x+=a:e.x>i&&(e.x-=a),e}(i,s,t[0]):i,e}))}(i,m,d,p),{count:b,min:I,max:x,mean:z,stdDev:y}=function(e,a=18,i,n,o,l){const r=new Float64Array(o*l);a=Math.round(Object(t.h)(a));let u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,f=0,m=0,d=0,p=0;const v=Object(s.c)(n,i);for(const{geometry:t,attributes:I}of e){const{x:e,y:i}=t,n=Math.max(0,e-a),b=Math.max(0,i-a),x=Math.min(l,i+a),z=Math.min(o,e+a),y=+v(I);for(let t=b;t<x;t++)for(let l=n;l<z;l++){const n=t*o+l,v=Object(s.d)(l-e,t-i,a),b=r[n];f=r[n]+=v*y;const I=f-b;m+=I,d+=I*I,f<u&&(u=f),f>c&&(c=f),p++}}if(!p)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const b=(c-u)/2;return{mean:m/p,stdDev:Math.sqrt((d-m*m/p)/p),min:u,max:c,mid:b,count:p}}(v,u,c,o,p[0],p[1]);return{count:b,min:I,max:x,avg:z,stddev:y}}}}]);
//# sourceMappingURL=196.18ce00fa.chunk.js.map